# Parser and Lexer Generator for WHILE Language

## Usage Instructions

Start the SML REPL in the current directory,

- run `use "while_ast.sml";` to generate the lexer and parser, and load the compiler structure into the SML REPL.
- run `While.compile <filepath>;` to create the AST from the WHILE language code stored in `<filepath>`.

## Directory Structure

Attached below is the structure of the directory.

- The `src/` directory contains the code of the parser, lexer, and their generators.
	- `while.cm` is the SML Compilation Manager file used to easily load the code.
	- `datatypes.sml` defines the data type of the AST generated.
	- `while.lex` is the ML-Lex code used for generating the lexer.
	- `while.yacc` is the ML-Yacc code used for generating the parser.
	- `glue.sml` is glue code for running ML-Lex and ML-Yacc with each other.
	- `compiler.sml` defines a structure which uses the parser and lexer generated to construct the AST from a file in WHILE language.
	- `while.yacc.desc` is a debugging file containing a description of the LR parser generated by ML-Yacc.
	- `while.yacc.sig` and `while.yacc.sml` define the parser generated by ML-Yacc.
	- `while.lex.sml` defines the lexer generated by ML-Lex.
- Loading `while_ast.sml` generates the parser and lexer.
- The `test/` directory contains sample programs in the WHILE language.

```
.
├── README.md
├── src
│   ├── compiler.sml
│   ├── datatypes.sml
│   ├── glue.sml
│   ├── while.cm
│   ├── while.lex
│   ├── while.lex.sml
│   ├── while.yacc
│   ├── while.yacc.desc
│   ├── while.yacc.sig
│   └── while.yacc.sml
├── test
│   ├── bad1.wh
│   ├── bad2.wh
│   ├── empty.wh
│   ├── good1.wh
│   ├── good2.wh
│   └── good3.wh
└── while_ast.sml
```

## Context-Free Grammar
The CFG generating the language is given by,
```ebnf
begin          = "program" identifier "::" block
block          = declarationseq commandseq
declarationseq = {declaration}
declaration    = "var" varlist ":" type
type           = "int" | "bool"
varlist        = variable {"," variable}
variable       = identifier
commandseq     = "{" {command ";"} "}"
command        = variable ":=" expression
               | "read" variable
	       | "write" expression
	       | "if" expression "then" commandseq "else" commandseq "endif"
	       | "while" expression "do" commandseq "endwh"
expression     = expression addop expression
               | expression boolop expression
	       | expression mulop expression
	       | expression relop expression
	       | "(" expression ")"
	       | unaryop expression
               | integer
	       | "tt" | "ff"
integer        = digit{digit}
identifier     = letter{letter | digit}
unaryop        = "~" | "!"
mulop          = "*" | "/" | "%"
addop          = "+" | "-"
relop          = "<" | "<=" | "=" | "<>" | ">=" | ">"
boolop         = "&&" | "||"
```

where `digit` and `letter` are non-terminals which derive the digits `0` to `9` and the alphabetical characters `a` to `z` and `A` to `Z` respectively.

The CFG as defined above is ambiguous because of the (lack of) associativity and precedence of operations. These operators are, in order of _decreasing_ precedence.

| Operation      | Symbols                         | Associativity   |
| -------------- | ------------------------------- | --------------- |
| Unary          | `!`, `~`                        | right           |
| Multiplicative | `*`, `/`, `%`                   | left            |
| Additive       | `+`, `-`                        | left            |
| Relational     | `<`, `<=`, `=`, `<>`, `>=`, `>` | non-associative |
| Boolean AND    | `&&`                            | left            |
| Boolean OR     | `||`                            | left            |

## AST datatype definition

```sml
structure AST =
struct
  type Var = string
  datatype
      Prog   = PROG     of string * Blk
  and Blk    = BLK      of (Dec list) * (Cmd list)
  and Dec    = INT      of Var
             | BOOL     of Var
  and Cmd    = SET      of Var * Exp
             | READ     of Var
             | WRITE    of Exp
             | ITE      of Exp * (Cmd list) * (Cmd list)
             | WH       of Exp * (Cmd list)
  and Exp    = (* boolean operators *)
               AND      of Exp * Exp
             | OR       of Exp * Exp
             | NOT      of Exp
             (* relational operators *)
             | LT       of Exp * Exp
             | LEQ      of Exp * Exp
             | EQ       of Exp * Exp
             | GT       of Exp * Exp
             | GEQ      of Exp * Exp
             | NEQ      of Exp * Exp
             (* integer operators *)
             | PLUS     of Exp * Exp
             | MINUS    of Exp * Exp
             | TIMES    of Exp * Exp
             | DIV      of Exp * Exp
             | MOD      of Exp * Exp
             | NEGATIVE of Exp
             (* terminals *)
             | VAR      of Var
             | INTVAL   of int
             | BOOLVAL  of bool
end;
```

## Syntax-directed translation

```ebnf
begin          = "program" identifier "::" block
block          = declarationseq commandseq
declarationseq = {declaration}
declaration    = "var" varlist ":" type
type           = "int" | "bool"
varlist        = variable {"," variable}
variable       = identifier
commandseq     = "{" {command ";"} "}"
command        = variable ":=" expression
               | "read" variable
	       | "write" expression
	       | "if" expression "then" commandseq "else" commandseq "endif"
	       | "while" expression "do" commandseq "endwh"
expression     = expression addop expression
               | expression boolop expression
	       | expression mulop expression
	       | expression relop expression
	       | "(" expression ")"
	       | unaryop expression
               | integer
	       | "tt" | "ff"
integer        = digit{digit}
identifier     = letter{letter | digit}
unaryop        = "~" | "!"
mulop          = "*" | "/" | "%"
addop          = "+" | "-"
relop          = "<" | "<=" | "=" | "<>" | ">=" | ">"
boolop         = "&&" | "||"
```



## Auxiliary functions and Data


## Other Design Decisions

## Other Implementation Decisions

## Acknowledgements

